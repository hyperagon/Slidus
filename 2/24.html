<!--
    Clear background on backspace
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slidus 2.4</title>
    <style>
        :root {
            --bg-color: #1e1e24;
            --panel-bg: #2b2b36;
            --text-color: #e0e0e0;
            --accent-color: #4a90e2;
            --accent-hover: #357abd;
            --danger-color: #e74c3c;
            --border-color: #444450;
            --toolbar-width: 280px;
            --control-color: #e74c3c;
            --snap-radius: 12px;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            user-select: none;
            -webkit-user-select: none;
        }

        #app {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* Background Layer for Image */
        #bg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            z-index: 0;
            pointer-events: none;
            opacity: 0.5;
            transition: opacity 0.3s ease;
        }

        body.drag-over #bg-layer {
            opacity: 0.2;
        }
        
        body.drag-over::after {
            content: "Drop Image to Set Background";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 12px;
            font-size: 1.2rem;
            font-weight: bold;
            pointer-events: none;
            z-index: 100;
            border: 2px solid var(--accent-color);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        /* SVG Canvas */
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            z-index: 1; 
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            overflow: visible; 
            touch-action: none; 
        }

        body.mode-select #canvas {
            cursor: default;
        }
        
        body.mode-select .path-element {
            cursor: pointer; 
            pointer-events: stroke; 
        }
        body.mode-draw .path-element {
            pointer-events: none; 
        }

        /* Handles UI */
        .handle-group {
            pointer-events: none; 
        }
        .handle-group > * {
            pointer-events: auto; 
        }

        /* Node Handles (Squares) */
        .handle-node {
            fill: #fff;
            stroke: var(--accent-color);
            stroke-width: 2px;
            cursor: pointer; 
        }
        .handle-node:hover {
            fill: var(--accent-color);
            stroke: #fff;
        }

        /* Snap Indicator (Ghost Node) */
        .snap-indicator {
            display: none;
            pointer-events: none;
        }
        .snap-indicator circle {
            stroke: var(--accent-color);
            stroke-width: 2px;
            fill: rgba(74, 144, 226, 0.3);
        }

        /* Control Nodes (Circles) */
        .handle-control {
            fill: var(--bg-color);
            stroke: var(--control-color);
            stroke-width: 2px;
            cursor: move;
        }
        .handle-control:hover {
            fill: var(--control-color);
            stroke: #fff;
        }

        /* Control Lines */
        .handle-control-line {
            stroke: var(--control-color);
            stroke-width: 1;
            opacity: 0.6;
            pointer-events: none;
        }

        /* Closing Line (Dashed) */
        .handle-closing-line {
            stroke: var(--accent-color);
            stroke-width: 2;
            stroke-dasharray: 6, 4;
            opacity: 0.8;
            pointer-events: none;
        }

        /* Path Mover (The Cross) */
        .path-mover-group {
            cursor: grab;
            pointer-events: auto;
        }
        .path-mover-group:active {
            cursor: grabbing;
        }
        .cross-line {
            stroke: var(--text-color);
            stroke-width: 3;
            stroke-linecap: round;
            pointer-events: none;
        }
        .cross-hitbox {
            fill: transparent;
            stroke: transparent;
        }
        .path-mover-group:hover .cross-line {
            stroke: var(--accent-color);
            stroke-width: 4;
        }

        /* Toolbar Styles */
        .toolbar {
            position: absolute;
            top: 20px;
            left: 20px; 
            width: var(--toolbar-width);
            background-color: var(--panel-bg);
            padding: 16px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            gap: 16px;
            border: 1px solid var(--border-color);
            z-index: 10; 
            transition: transform 0.2s, opacity 0.2s;
        }

        .toolbar.toolbar-right {
            left: auto;
            right: 20px;
        }

        .toolbar.minimized {
            opacity: 0;
            pointer-events: none;
            transform: translateY(-10px);
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: transparent;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
        }
        .close-btn:hover {
            color: #fff;
            background: rgba(255,255,255,0.1);
        }

        .toolbar-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .toolbar-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
        }

        .side-by-side {
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }

        .side-by-side > div {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .side-by-side > div label {
            font-size: 0.75rem;
            color: #888;
        }

        .button-row {
            display: flex;
            gap: 8px;
        }

        button {
            flex: 1;
            padding: 10px 12px;
            border: none;
            border-radius: 4px;
            background-color: #3e3e4a;
            color: var(--text-color);
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        button:hover {
            background-color: #50505e;
        }

        button.active {
            background-color: var(--accent-color);
            color: white;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(74, 144, 226, 0.4);
        }

        button.danger {
            background-color: rgba(231, 76, 60, 0.15);
            color: var(--danger-color);
            border: 1px solid rgba(231, 76, 60, 0.3);
        }

        button.danger:hover {
            background-color: var(--danger-color);
            color: white;
        }

        button.export-btn {
            background-color: #27ae60;
            color: white;
            font-weight: 600;
        }
        button.export-btn:hover {
            background-color: #219150;
        }

        input[type="color"] {
            width: 100%;
            height: 36px;
            border: none;
            background: none;
            cursor: pointer;
            padding: 0;
            border-radius: 4px;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--accent-color);
        }
        
        .value-display {
            color: var(--accent-color);
            font-weight: normal;
        }

        .status-text {
            font-size: 0.8rem;
            color: #aaa;
            margin-top: 8px;
            line-height: 1.4;
            border-top: 1px solid var(--border-color);
            padding-top: 10px;
            background: rgba(0,0,0,0.2);
            padding: 8px;
            border-radius: 4px;
        }

        /* FAB */
        #fab {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--panel-bg);
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            z-index: 5;
            pointer-events: none;
            opacity: 0;
            transform: scale(0.8);
            transition: transform 0.2s, opacity 0.2s;
        }

        #fab.visible {
            pointer-events: auto;
            opacity: 1;
            transform: scale(1);
        }

        #fab:hover {
            background-color: var(--accent-color);
            color: white;
        }

        #fab.fab-right {
            left: auto;
            right: 20px;
        }

        #fab svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }

    </style>
</head>
<body class="mode-select">

    <div id="app">
        <div id="bg-layer"></div>

        <div id="fab" title="Open Toolbar"></div>

        <nav class="toolbar" id="toolbar">
            <button class="close-btn" id="btn-close-toolbar" title="Minimize Toolbar">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>

            <div class="toolbar-group">
                <div class="toolbar-label">Tools</div>
                <div class="button-row">
                    <button id="btn-draw">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg> 
                        Draw
                    </button>
                    <button id="btn-select" class="active">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M7 2l12 11.2-5.8.5 3.3 7.3-2.2.9-3.2-7.4-4.4 4.6z"/></svg>
                        Select
                    </button>
                </div>
            </div>

            <div class="toolbar-group">
                <div class="side-by-side">
                    <div>
                        <label for="stroke-color">Stroke</label>
                        <input type="color" id="stroke-color" value="#4a90e2">
                    </div>
                    <div>
                        <label for="fill-color">Fill</label>
                        <input type="color" id="fill-color" value="#ffffff">
                    </div>
                </div>
            </div>

            <div class="toolbar-group">
                <div class="side-by-side">
                    <div>
                        <label for="stroke-opacity">Str. Op.</label>
                        <input type="range" id="stroke-opacity" min="0" max="1" step="0.1" value="1">
                    </div>
                    <div>
                        <label for="fill-opacity">Fill Op.</label>
                        <input type="range" id="fill-opacity" min="0" max="1" step="0.1" value="0">
                    </div>
                </div>
            </div>

            <!-- Close Shape Toggle -->
            <div class="toolbar-group">
                <button id="btn-close-shape">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M4 12h16"></path>
                        <path d="M12 4v16"></path>
                        <circle cx="12" cy="12" r="10"></circle>
                    </svg>
                    Close / Merge
                </button>
            </div>

            <div class="toolbar-group">
                <div class="toolbar-label">
                    <span>Stroke Width</span>
                    <span id="width-val" class="value-display">4px</span>
                </div>
                <input type="range" id="width-slider" min="1" max="100" value="4">
            </div>

            <div class="toolbar-group">
                <div class="toolbar-label">Actions</div>
                <button id="btn-export" class="export-btn">Export SVG</button>
                <button id="btn-delete-selected" class="danger" style="display: none;">Delete Selected</button>
                <button id="btn-clear">Clear All</button>
            </div>
            
            <div class="status-text" id="status-text">
                <b>Select Mode:</b> Click path to select.<br>
                <b>Red Circles</b> = Control Handles (Drag to curve).<br>
                <b>White Squares</b> = Anchors.<br>
                <span style='color:var(--accent-color)'>Double-click Anchor</span> to delete.<br>
                <span style='color:var(--accent-color)'>Double-click line</span> to add point.<br>
                Drag <span style='color:#fff'>Cross</span> to move whole path.<br>
                <b style='color:#e74c3c'>Snapping:</b> Drag anchor near other points to snap.<br>
                <b style='color:#e74c3c'>Merge:</b> Select 2 paths & click "Close / Merge".<br>
                <b>Backspace:</b> Clears background if nothing selected.
            </div>
        </nav>

        <svg id="canvas">
            <defs>
                <filter id="glow" x="-20%" y="-20%" width="140%" height="140%">
                    <feGaussianBlur stdDeviation="2" result="blur" />
                    <feComposite in="SourceGraphic" in2="blur" operator="over" />
                </filter>
            </defs>
            <g id="layer-paths"></g>
            <g id="layer-handles"></g>
            <!-- Snap Indicator Overlay -->
            <g id="layer-snap-indicator" class="snap-indicator">
                <circle id="snap-ring" r="12" fill="none" stroke="#e74c3c" stroke-width="2" stroke-dasharray="4 2" opacity="0.9"></circle>
                <circle id="snap-center" r="5" fill="#fff" stroke="#e74c3c" stroke-width="2"></circle>
            </g>
        </svg>
    </div>

    <script>
        "use strict";
        
        const AppState = {
            mode: 'select', 
            isDrawing: false,
            isDraggingHandle: false,
            isDraggingPath: false,
            isDraggingSegment: false, 
            isSnapping: false,
            currentPathIndex: -1,
            selectedPathIndices: [], 
            activeHandleIndex: null, 
            activeSegmentIndex: null, 
            dragStartMouse: { x: 0, y: 0 },
            paths: [], 
            rawPoints: [], 
            styles: {
                strokeColor: '#4a90e2',
                fillColor: '#ffffff',
                strokeOpacity: 1.0,
                fillOpacity: 0.0, 
                width: 4,
                drawThreshold: 10,
                autoClose: false,
                snapThreshold: 12
            },
            toolbarState: {
                isLeft: true,
                isToolbarOpen: true,
                bufferDistance: 40
            },
            snapTarget: null
        };

        const History = {
            undoStack: [],
            redoStack: [],
            limit: 50
        };

        const UI = {
            app: document.getElementById('app'),
            bgLayer: document.getElementById('bg-layer'),
            canvas: document.getElementById('canvas'),
            layerPaths: document.getElementById('layer-paths'),
            layerHandles: document.getElementById('layer-handles'),
            layerSnap: document.getElementById('layer-snap-indicator'),
            snapRing: document.getElementById('snap-ring'),
            snapCenter: document.getElementById('snap-center'),
            toolbar: document.getElementById('toolbar'),
            fab: document.getElementById('fab'),
            btnDraw: document.getElementById('btn-draw'),
            btnSelect: document.getElementById('btn-select'),
            btnCloseShape: document.getElementById('btn-close-shape'),
            btnExport: document.getElementById('btn-export'),
            btnDelete: document.getElementById('btn-delete-selected'),
            btnClear: document.getElementById('btn-clear'),
            btnCloseToolbar: document.getElementById('btn-close-toolbar'),
            strokeColor: document.getElementById('stroke-color'),
            fillColor: document.getElementById('fill-color'),
            strokeOpacity: document.getElementById('stroke-opacity'),
            fillOpacity: document.getElementById('fill-opacity'),
            widthSlider: document.getElementById('width-slider'),
            widthVal: document.getElementById('width-val'),
            statusText: document.getElementById('status-text'),
            body: document.body
        };

        const Icons = {
            draw: '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>',
            select: '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M7 2l12 11.2-5.8.5 3.3 7.3-2.2.9-3.2-7.4-4.4 4.6z"/></svg>',
            menu: '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>'
        };

        function saveState() {
            const snapshot = JSON.parse(JSON.stringify(AppState.paths));
            History.undoStack.push(snapshot);
            if (History.undoStack.length > History.limit) History.undoStack.shift();
            History.redoStack = []; 
        }

        function undo() {
            if (AppState.isDrawing) {
                cancelDrawing();
                return;
            }
            if (History.undoStack.length === 0) return;
            History.redoStack.push(JSON.parse(JSON.stringify(AppState.paths)));
            const previousState = History.undoStack.pop();
            AppState.paths = previousState;
            AppState.selectedPathIndices = AppState.selectedPathIndices.filter(idx => idx < AppState.paths.length);
            rebuildCanvas();
        }

        function redo() {
            if (AppState.isDrawing) return;
            if (History.redoStack.length === 0) return;
            History.undoStack.push(JSON.parse(JSON.stringify(AppState.paths)));
            const nextState = History.redoStack.pop();
            AppState.paths = nextState;
            AppState.selectedPathIndices = AppState.selectedPathIndices.filter(idx => idx < AppState.paths.length);
            rebuildCanvas();
        }

        function cancelDrawing() {
            AppState.isDrawing = false;
            AppState.isSnapping = false;
            AppState.snapTarget = null;
            UI.layerSnap.style.display = 'none';
            AppState.rawPoints = [];
            const currentEl = UI.layerPaths.lastElementChild;
            if (currentEl) currentEl.remove();
            AppState.currentPathIndex = -1;
        }

        function rebuildCanvas() {
            UI.layerPaths.innerHTML = '';
            UI.layerHandles.innerHTML = '';
            AppState.paths.forEach((pathData, index) => {
                const pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");
                pathEl.setAttribute("class", "path-element");
                pathEl.style.isolation = "isolate";
                
                pathEl.setAttribute("stroke", pathData.strokeColor);
                pathEl.setAttribute("stroke-width", pathData.width);
                pathEl.setAttribute("stroke-opacity", pathData.strokeOpacity !== undefined ? pathData.strokeOpacity : 1);
                pathEl.setAttribute("fill", pathData.fillColor);
                pathEl.setAttribute("fill-opacity", pathData.fillOpacity !== undefined ? pathData.fillOpacity : 0);
                pathEl.setAttribute("stroke-linecap", "round");
                pathEl.setAttribute("stroke-linejoin", "round");
                pathEl.dataset.index = index;
                
                pathEl.addEventListener('dblclick', (e) => handlePathDoubleClick(e, index));

                UI.layerPaths.appendChild(pathEl);
                updatePathD(index);
            });
            renderSelectionHandles();
        }

        function getSVGPoint(clientX, clientY) {
            const pt = UI.canvas.createSVGPoint();
            pt.x = clientX;
            pt.y = clientY;
            return pt.matrixTransform(UI.canvas.getScreenCTM().inverse());
        }

        function setStatus(msg) {
            UI.statusText.innerHTML = msg;
        }

        function checkToolbarProximity(clientX) {
            if (AppState.mode !== 'draw') return;
            const activeElement = AppState.toolbarState.isToolbarOpen ? UI.toolbar : UI.fab;
            if (!AppState.toolbarState.isToolbarOpen && !UI.fab.classList.contains('visible')) return;
            const rect = activeElement.getBoundingClientRect();
            const buffer = AppState.toolbarState.bufferDistance; 

            if (AppState.toolbarState.isLeft) {
                if (clientX < (rect.right + buffer)) moveToolbarTo('right');
            } else {
                if (clientX > (rect.left - buffer)) moveToolbarTo('left');
            }
        }

        function moveToolbarTo(side) {
            if (side === 'right') {
                AppState.toolbarState.isLeft = false;
                UI.toolbar.classList.remove('toolbar-left');
                UI.toolbar.classList.add('toolbar-right');
                UI.fab.classList.remove('fab-left');
                UI.fab.classList.add('fab-right');
            } else {
                AppState.toolbarState.isLeft = true;
                UI.toolbar.classList.remove('toolbar-right');
                UI.toolbar.classList.add('toolbar-left');
                UI.fab.classList.remove('fab-right');
                UI.fab.classList.add('fab-left');
            }
        }

        function toggleToolbar() {
            AppState.toolbarState.isToolbarOpen = !AppState.toolbarState.isToolbarOpen;
            if (AppState.toolbarState.isToolbarOpen) {
                UI.toolbar.classList.remove('minimized');
                UI.fab.classList.remove('visible');
            } else {
                UI.toolbar.classList.add('minimized');
                UI.fab.classList.add('visible');
                updateFabIcon();
            }
        }

        function updateFabIcon() {
            if (AppState.mode === 'draw') {
                UI.fab.innerHTML = Icons.draw;
                UI.fab.title = "Draw Mode - Click to Open Toolbar";
            } else {
                UI.fab.innerHTML = Icons.select;
                UI.fab.title = "Select Mode - Click to Open Toolbar";
            }
        }

        function updateCloseShapeUI() {
            if (AppState.selectedPathIndices.length === 1) {
                const idx = AppState.selectedPathIndices[0];
                const path = AppState.paths[idx];
                if (path.closed) {
                    UI.btnCloseShape.classList.add('active');
                } else {
                    UI.btnCloseShape.classList.remove('active');
                }
            } else {
                if (AppState.styles.autoClose) {
                    UI.btnCloseShape.classList.add('active');
                } else {
                    UI.btnCloseShape.classList.remove('active');
                }
            }
        }

        // --- MATH & LOGIC ---

        function lerp(a, b, t) { return a + (b - a) * t; }
        
        function cubicBezier(p0, cp0, cp1, p1, t) {
            const oneMinusT = 1 - t;
            return {
                x: Math.pow(oneMinusT, 3) * p0.x +
                   3 * Math.pow(oneMinusT, 2) * t * cp0.x +
                   3 * oneMinusT * Math.pow(t, 2) * cp1.x +
                   Math.pow(t, 3) * p1.x,
                y: Math.pow(oneMinusT, 3) * p0.y +
                   3 * Math.pow(oneMinusT, 2) * t * cp0.y +
                   3 * oneMinusT * Math.pow(t, 2) * cp1.y +
                   Math.pow(t, 3) * p1.y
            };
        }

        function getBezierSegmentDistance(p0, cp0, cp1, p1, pt) {
            let minDist = Infinity;
            for (let t = 0; t <= 1; t += 0.05) {
                const b = cubicBezier(p0, cp0, cp1, p1, t);
                const d = Math.hypot(b.x - pt.x, b.y - pt.y);
                if (d < minDist) minDist = d;
            }
            return minDist;
        }

        function simplifyPath(points, tolerance) {
            if (points.length <= 2) return points;

            let filtered = [points[0]];
            for (let i = 1; i < points.length; i++) {
                const d = Math.hypot(points[i].x - points[i-1].x, points[i].y - points[i-1].y);
                if (d > 5) { 
                    filtered.push(points[i]);
                }
            }
            if (filtered[filtered.length-1] !== points[points.length-1]) {
                filtered.push(points[points.length-1]);
            }
            points = filtered;

            points = ramerDouglasPeucker(points, tolerance);

            let optimized = points;
            let changed = true;
            const areaThreshold = 400; 
            
            for(let pass=0; pass<2; pass++) {
                changed = false;
                if (optimized.length <= 2) break;
                
                const nextOpt = [optimized[0]];
                for (let i = 1; i < optimized.length - 1; i++) {
                    const area = Math.abs(
                        (optimized[i-1].x * (optimized[i].y - optimized[i+1].y) +
                         optimized[i].x * (optimized[i+1].y - optimized[i-1].y) +
                         optimized[i+1].x * (optimized[i-1].y - optimized[i].y)) / 2
                    );
                    
                    if (area < areaThreshold) {
                        changed = true; 
                    } else {
                        nextOpt.push(optimized[i]);
                    }
                }
                nextOpt.push(optimized[optimized.length-1]);
                optimized = nextOpt;
            }

            return optimized;
        }

        function ramerDouglasPeucker(points, epsilon) {
            if (points.length <= 2) return points;
            
            let dmax = 0, index = 0, end = points.length - 1;
            for (let i = 1; i < end; i++) {
                const d = pointLineDistance(points[i], points[0], points[end]);
                if (d > dmax) { index = i; dmax = d; }
            }
            if (dmax > epsilon) {
                return ramerDouglasPeucker(points.slice(0, index + 1), epsilon).slice(0, -1).concat(ramerDouglasPeucker(points.slice(index, end + 1), epsilon));
            }
            return [points[0], points[end]];
        }

        function pointLineDistance(point, start, end) {
            let x = start.x, y = start.y, dx = end.x - x, dy = end.y - y;
            if (dx !== 0 || dy !== 0) {
                const t = ((point.x - x) * dx + (point.y - y) * dy) / (dx * dx + dy * dy);
                if (t > 1) { x = end.x; y = end.y; }
                else if (t > 0) { x += dx * t; y += dy * t; }
            }
            return Math.hypot(point.x - x, point.y - y);
        }

        function calculateControlPoints(points) {
            const result = points.map(p => ({ p: {...p}, cIn: {...p}, cOut: {...p} }));
            const n = points.length;

            if (n < 2) return result;

            const tension = 0.25; 

            for (let i = 0; i < n; i++) {
                const prev = points[Math.max(0, i - 1)];
                const curr = points[i];
                const next = points[Math.min(n - 1, i + 1)];
                
                const tx = (next.x - prev.x);
                const ty = (next.y - prev.y);

                let cpOutX = curr.x + tx * tension;
                let cpOutY = curr.y + ty * tension;
                let cpInX = curr.x - tx * tension;
                let cpInY = curr.y - ty * tension;

                if (i < n - 1) {
                    const dx = next.x - curr.x;
                    const dy = next.y - curr.y;
                    const distToNext = Math.hypot(dx, dy);
                    const cpDx = cpOutX - curr.x;
                    const cpDy = cpOutY - curr.y;
                    const cpDist = Math.hypot(cpDx, cpDy);
                    const maxLen = distToNext * 0.5;
                    if (cpDist > maxLen) {
                        const ratio = maxLen / cpDist;
                        cpOutX = curr.x + cpDx * ratio;
                        cpOutY = curr.y + cpDy * ratio;
                    }
                }

                if (i > 0) {
                    const dx = prev.x - curr.x;
                    const dy = prev.y - curr.y;
                    const distToPrev = Math.hypot(dx, dy);
                    const cpDx = cpInX - curr.x;
                    const cpDy = cpInY - curr.y;
                    const cpDist = Math.hypot(cpDx, cpDy);
                    const maxLen = distToPrev * 0.5;
                    if (cpDist > maxLen) {
                        const ratio = maxLen / cpDist;
                        cpInX = curr.x + cpDx * ratio;
                        cpInY = curr.y + cpDy * ratio;
                    }
                }

                result[i].cOut = { x: cpOutX, y: cpOutY };
                result[i].cIn = { x: cpInX, y: cpInY };
            }

            result[0].cIn = { x: result[0].p.x, y: result[0].p.y }; 
            result[n-1].cOut = { x: result[n-1].p.x, y: result[n-1].p.y };

            return result;
        }

        function getNearestSegmentIndex(pathData, pt) {
            const pts = pathData.points;
            let minDist = Infinity;
            let bestIndex = -1;

            for (let i = 0; i < pts.length - 1; i++) {
                const p1 = pts[i];
                const p2 = pts[i+1];
                const dist = getBezierSegmentDistance(p1.p, p1.cOut, p2.cIn, p2.p, pt);
                if (dist < minDist) {
                    minDist = dist;
                    bestIndex = i;
                }
            }
            return { index: bestIndex, dist: minDist };
        }

        function getTFromPoint(p0, cp0, cp1, p1, pt) {
            let bestT = 0.5;
            let bestDist = Infinity;
            for(let t = 0; t <= 1; t += 0.05) {
                const b = cubicBezier(p0, cp0, cp1, p1, t);
                const d = Math.hypot(b.x - pt.x, b.y - pt.y);
                if (d < bestDist) {
                    bestDist = d;
                    bestT = t;
                }
            }
            return { t: bestT, dist: bestDist };
        }

        function splitBezierCurve(p0, cp0, cp1, p1, t) {
            const u = 1 - t;
            const pA = { x: u*p0.x + t*cp0.x, y: u*p0.y + t*cp0.y };
            const pB = { x: u*cp0.x + t*cp1.x, y: u*cp0.y + t*cp1.y };
            const pC = { x: u*cp1.x + t*p1.x, y: u*cp1.y + t*p1.y };

            const pD = { x: u*pA.x + t*pB.x, y: u*pA.y + t*pB.y };
            const pE = { x: u*pB.x + t*pC.x, y: u*pB.y + t*pC.y };

            const pMid = { x: u*pD.x + t*pE.x, y: u*pD.y + t*pE.y };

            const left = { p: p0, cOut: pA, cIn: { x: p0.x, y: p0.y } };
            const right = { p: pMid, cOut: pE, cIn: pC };
            
            return {
                leftNode: left,
                splitNode: { p: pMid, cIn: pD, cOut: pE },
                rightNode: { p: p1, cIn: pC }
            };
        }

        // --- DRAWING ---

        function startDrawing(x, y) {
            AppState.isDrawing = true;
            AppState.rawPoints = [{ x, y }];
            
            const pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");
            pathEl.setAttribute("class", "path-element");
            pathEl.setAttribute("stroke", AppState.styles.strokeColor);
            pathEl.setAttribute("fill", AppState.styles.fillColor);
            pathEl.setAttribute("stroke-width", AppState.styles.width);
            pathEl.setAttribute("stroke-opacity", AppState.styles.strokeOpacity);
            pathEl.setAttribute("fill-opacity", AppState.styles.fillOpacity);
            pathEl.setAttribute("stroke-linecap", "round");
            pathEl.setAttribute("stroke-linejoin", "round");
            pathEl.dataset.index = AppState.paths.length;
            UI.layerPaths.appendChild(pathEl);
        }

        function drawMove(x, y) {
            if (!AppState.isDrawing) return;
            const lastPoint = AppState.rawPoints[AppState.rawPoints.length - 1];
            const dist = Math.hypot(x - lastPoint.x, y - lastPoint.y);
            
            if (dist > AppState.styles.drawThreshold) {
                AppState.rawPoints.push({ x, y });
                const d = AppState.rawPoints.reduce((acc, p, i) => {
                    return acc + (i === 0 ? `M ${p.x.toFixed(1)} ${p.y.toFixed(1)}` : ` L ${p.x.toFixed(1)} ${p.y.toFixed(1)}`);
                }, "");
                const pathEl = UI.layerPaths.lastElementChild;
                if (pathEl) pathEl.setAttribute("d", d);
            }
        }

        function stopDrawing() {
            if (!AppState.isDrawing) return;
            AppState.isDrawing = false;
            
            if (AppState.rawPoints.length > 1) {
                const anchors = simplifyPath(AppState.rawPoints, 20.0);
                const splinePoints = calculateControlPoints(anchors);

                const newPath = {
                    strokeColor: AppState.styles.strokeColor,
                    fillColor: AppState.styles.fillColor,
                    strokeOpacity: AppState.styles.strokeOpacity,
                    fillOpacity: AppState.styles.fillOpacity,
                    width: parseInt(AppState.styles.width),
                    points: splinePoints,
                    closed: AppState.styles.autoClose
                };
                
                AppState.paths.push(newPath);
                AppState.currentPathIndex = AppState.paths.length - 1;
                
                const newEl = UI.layerPaths.lastElementChild;
                newEl.addEventListener('dblclick', (e) => handlePathDoubleClick(e, AppState.currentPathIndex));

                updatePathD(AppState.currentPathIndex);
                
                AppState.selectedPathIndices = [AppState.currentPathIndex];
                updateSelectionVisuals();
                
                saveState();
            } else {
                const pathEl = UI.layerPaths.lastElementChild;
                if(pathEl) pathEl.remove();
            }
            AppState.rawPoints = [];
        }

        function updatePathD(index) {
            const pathData = AppState.paths[index];
            if (!pathData || !pathData.points) return;
            const pts = pathData.points;
            if (pts.length === 0) return;

            let d = `M ${pts[0].p.x.toFixed(1)} ${pts[0].p.y.toFixed(1)}`;
            
            for (let i = 0; i < pts.length - 1; i++) {
                const p1 = pts[i];
                const p2 = pts[i+1];
                d += ` C ${p1.cOut.x.toFixed(1)} ${p1.cOut.y.toFixed(1)}, ${p2.cIn.x.toFixed(1)} ${p2.cIn.y.toFixed(1)}, ${p2.p.x.toFixed(1)} ${p2.p.y.toFixed(1)}`;
            }

            if (pathData.closed) {
                d += " Z";
            }

            const pathEl = UI.layerPaths.querySelector(`path[data-index="${index}"]`);
            if (pathEl) pathEl.setAttribute("d", d);
        }

        // --- SELECTION & EDITING ---

        function toggleSelection(index, shiftKey) {
            if (index === -1) {
                AppState.selectedPathIndices = [];
                updateSelectionVisuals();
                return;
            }

            if (shiftKey) {
                const idxPos = AppState.selectedPathIndices.indexOf(index);
                if (idxPos > -1) {
                    AppState.selectedPathIndices.splice(idxPos, 1); 
                } else {
                    AppState.selectedPathIndices.push(index); 
                }
            } else {
                AppState.selectedPathIndices = [index];
            }
            updateSelectionVisuals();
        }

        function updateSelectionVisuals() {
            AppState.selectedPathIndices.forEach(idx => {
                const pathEl = UI.layerPaths.querySelector(`path[data-index="${idx}"]`);
                if (pathEl && pathEl.parentNode) {
                    pathEl.parentNode.appendChild(pathEl);
                }
            });

            if (AppState.selectedPathIndices.length > 0) {
                const idx = AppState.selectedPathIndices[0];
                const pathData = AppState.paths[idx];
                
                UI.widthSlider.value = pathData.width;
                UI.widthVal.textContent = pathData.width + "px";
                UI.strokeColor.value = pathData.strokeColor;
                UI.fillColor.value = pathData.fillColor;
                UI.strokeOpacity.value = pathData.strokeOpacity !== undefined ? pathData.strokeOpacity : 1;
                UI.fillOpacity.value = pathData.fillOpacity !== undefined ? pathData.fillOpacity : 0;

                UI.btnDelete.style.display = "block";
                setStatus(`Selected ${AppState.selectedPathIndices.length} path(s).`);
                updateCloseShapeUI();
            } else {
                UI.widthSlider.value = AppState.styles.width;
                UI.widthVal.textContent = AppState.styles.width + "px";
                UI.strokeColor.value = AppState.styles.strokeColor;
                UI.fillColor.value = AppState.styles.fillColor;
                UI.strokeOpacity.value = AppState.styles.strokeOpacity;
                UI.fillOpacity.value = AppState.styles.fillOpacity;
                UI.btnDelete.style.display = "none";
                setStatus("Select Mode. Click a path to select.");
                updateCloseShapeUI();
            }

            renderSelectionHandles();
        }

        function clearHandles() {
            UI.layerHandles.innerHTML = '';
        }

        function renderSelectionHandles() {
            clearHandles();
            AppState.selectedPathIndices.forEach(index => {
                renderHandlesForPath(index);
            });
        }

        function renderHandlesForPath(index) {
            const pathData = AppState.paths[index];
            const pts = pathData.points;
            
            const gLines = document.createElementNS("http://www.w3.org/2000/svg", "g");
            const gHandles = document.createElementNS("http://www.w3.org/2000/svg", "g");
            gHandles.setAttribute("class", "handle-group");

            pts.forEach((pt, i) => {
                if (i < pts.length - 1) {
                    const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    l.setAttribute("x1", pt.p.x); l.setAttribute("y1", pt.p.y);
                    l.setAttribute("x2", pt.cOut.x); l.setAttribute("y2", pt.cOut.y);
                    l.setAttribute("class", "handle-control-line");
                    gLines.appendChild(l);
                }
                if (i > 0) {
                    const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    l.setAttribute("x1", pt.p.x); l.setAttribute("y1", pt.p.y);
                    l.setAttribute("x2", pt.cIn.x); l.setAttribute("y2", pt.cIn.y);
                    l.setAttribute("class", "handle-control-line");
                    gLines.appendChild(l);
                }

                createHandle(gHandles, pt.p, 'anchor', i, index);

                if (i < pts.length - 1) {
                    createHandle(gHandles, pt.cOut, 'control', i, index, 'cOut');
                }
                if (i > 0) {
                    createHandle(gHandles, pt.cIn, 'control', i, index, 'cIn');
                }
            });

            if (pathData.closed && pts.length > 2) {
                const first = pts[0];
                const last = pts[pts.length - 1];
                const closingLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
                closingLine.setAttribute("x1", last.p.x); 
                closingLine.setAttribute("y1", last.p.y);
                closingLine.setAttribute("x2", first.p.x); 
                closingLine.setAttribute("y2", first.p.y);
                closingLine.setAttribute("class", "handle-closing-line");
                gLines.appendChild(closingLine);
            }

            UI.layerHandles.appendChild(gLines);
            UI.layerHandles.appendChild(gHandles);

            const minX = Math.min(...pts.map(pt => pt.p.x));
            const minY = Math.min(...pts.map(pt => pt.p.y));

            const moverOffset = 25;
            
            const moverGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            moverGroup.setAttribute("transform", `translate(${minX - moverOffset}, ${minY - moverOffset})`);
            moverGroup.setAttribute("class", "path-mover-group");
            
            const mSize = 10;
            const hLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
            hLine.setAttribute("x1", -mSize); hLine.setAttribute("y1", 0);
            hLine.setAttribute("x2", mSize); hLine.setAttribute("y2", 0);
            hLine.setAttribute("class", "cross-line");
            
            const vLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
            vLine.setAttribute("x1", 0); vLine.setAttribute("y1", -mSize);
            vLine.setAttribute("x2", 0); vLine.setAttribute("y2", mSize);
            vLine.setAttribute("class", "cross-line");
            
            const hitbox = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            hitbox.setAttribute("x", -mSize); hitbox.setAttribute("y", -mSize);
            hitbox.setAttribute("width", mSize*2); hitbox.setAttribute("height", mSize*2);
            hitbox.setAttribute("class", "cross-hitbox");
            
            moverGroup.appendChild(hLine);
            moverGroup.appendChild(vLine);
            moverGroup.appendChild(hitbox);
            
            moverGroup.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                startDraggingPath(e, index);
            });
            
            UI.layerHandles.appendChild(moverGroup);
        }

        function createHandle(container, point, type, index, pathIndex, subType = '') {
            const el = document.createElementNS("http://www.w3.org/2000/svg", type === 'anchor' ? 'rect' : 'circle');
            const size = 6;
            const radius = 4;

            if (type === 'anchor') {
                el.setAttribute("x", point.x - size/2);
                el.setAttribute("y", point.y - size/2);
                el.setAttribute("width", size);
                el.setAttribute("height", size);
                el.setAttribute("class", "handle-node");
                
                el.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    e.preventDefault(); 
                    deletePoint(index, pathIndex);
                });

            } else {
                el.setAttribute("cx", point.x);
                el.setAttribute("cy", point.y);
                el.setAttribute("r", radius);
                el.setAttribute("class", "handle-control");
            }

            el.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                startDraggingHandle(e, index, subType, pathIndex);
            });
            container.appendChild(el);
        }

        function handlePathDoubleClick(e, pathIndex) {
            if (AppState.mode !== 'select') return;
            
            const pt = getSVGPoint(e.clientX, e.clientY);
            const pathData = AppState.paths[pathIndex];
            const pts = pathData.points;
            
            if (pts.length < 2) return;

            let minDist = Infinity;
            let bestIndex = -1;
            let bestT = 0.5;

            for (let i = 0; i < pts.length - 1; i++) {
                const p0 = pts[i];
                const p1 = pts[i+1];
                
                const { t, dist } = getTFromPoint(p0.p, p0.cOut, p1.cIn, p1.p, pt);
                
                if (dist < minDist) {
                    minDist = dist;
                    bestIndex = i;
                    bestT = t;
                }
            }
            
            if (minDist < 20 && bestIndex !== -1) {
                saveState();
                
                const p0 = pts[bestIndex];
                const p1 = pts[bestIndex+1];

                const { leftNode, splitNode, rightNode } = splitBezierCurve(
                    p0.p, p0.cOut, p1.cIn, p1.p, bestT
                );

                pts[bestIndex].cOut = leftNode.cOut;
                pts[bestIndex+1].cIn = rightNode.cIn;

                pts.splice(bestIndex + 1, 0, splitNode);

                updatePathD(pathIndex);
                renderSelectionHandles();
            }
        }

        function deletePoint(index, pathIndex) {
            const pathData = AppState.paths[pathIndex];
            if (!pathData || pathData.points.length <= 2) return;

            saveState();
            
            pathData.points.splice(index, 1);
            
            const tension = 0.25; 

            if (index < pathData.points.length) {
                const curr = pathData.points[index];
                if (curr && index > 0) {
                    const prev = pathData.points[index - 1];
                    const next = pathData.points[index + 1] || {p: curr.p}; 
                    const tangentX = (next.p.x - prev.p.x) * tension;
                    const tangentY = (next.p.y - prev.p.y) * tension;
                    curr.cIn = { x: curr.p.x - tangentX, y: curr.p.y - tangentY };
                }
            }

            if (index - 1 >= 0) {
                const prev = pathData.points[index - 1];
                const curr = pathData.points[index];
                const next = pathData.points[index + 1] || {p: curr.p};
                if (prev) {
                    const tangentX = (next.p.x - prev.p.x) * tension;
                    const tangentY = (next.p.y - prev.p.y) * tension;
                    prev.cOut = { x: prev.p.x + tangentX, y: prev.p.y + tangentY };
                }
            }

            if (index === 0 && pathData.points.length > 0) {
                pathData.points[0].cIn = { ...pathData.points[0].p };
            }

            updatePathD(pathIndex);
            renderSelectionHandles();
        }

        function startDraggingHandle(e, index, subType, pathIndex) {
            if (AppState.mode !== 'select') return;
            e.stopPropagation();
            AppState.isDraggingHandle = true;
            AppState.activeHandleIndex = { index, subType, pathIndex };
            const pt = getSVGPoint(e.clientX, e.clientY);
            AppState.dragStartMouse = { x: pt.x, y: pt.y };
            
            if (subType === '') {
                AppState.snapTarget = null;
            }
        }

        function startDraggingPath(e, pathIndex) {
            if (AppState.mode !== 'select') return;
            
            if (!AppState.selectedPathIndices.includes(pathIndex)) {
                toggleSelection(pathIndex, e.shiftKey);
            }

            AppState.isDraggingPath = true;
            const pt = getSVGPoint(e.clientX, e.clientY);
            AppState.dragStartMouse = { x: pt.x, y: pt.y };
        }

        function startDraggingSegment(e, pathIndex) {
            if (AppState.mode !== 'select') return;
            e.preventDefault();
            e.stopPropagation();
            
            const pt = getSVGPoint(e.clientX, e.clientY);
            const pathData = AppState.paths[pathIndex];
            
            const { index, dist } = getNearestSegmentIndex(pathData, pt);
            
            if (index !== -1 && dist < 20) {
                toggleSelection(pathIndex, e.shiftKey);
                AppState.isDraggingSegment = true;
                AppState.activeSegmentIndex = index;
                AppState.activePathIndex = pathIndex; 
                AppState.dragStartMouse = { x: pt.x, y: pt.y };
            } else {
                toggleSelection(pathIndex, e.shiftKey);
            }
        }

        // --- SNAP LOGIC ---
        
        function findSnapTarget(x, y, currentPathIdx, currentPtIdx) {
            const threshold = AppState.styles.snapThreshold;
            let bestTarget = null;
            let minDist = threshold;

            AppState.paths.forEach((path, pIdx) => {
                path.points.forEach((pt, i) => {
                    if (pIdx === currentPathIdx && Math.abs(i - currentPtIdx) <= 1) return;
                    
                    const d = Math.hypot(pt.p.x - x, pt.p.y - y);
                    if (d < minDist) {
                        minDist = d;
                        bestTarget = { type: 'anchor', x: pt.p.x, y: pt.p.y, pathIdx: pIdx, ptIdx: i };
                    }
                });
            });

            if (!bestTarget) {
                AppState.paths.forEach((path, pIdx) => {
                    for (let i = 0; i < path.points.length - 1; i++) {
                        if (pIdx === currentPathIdx && Math.abs(i - currentPtIdx) <= 1) continue;

                        const p0 = path.points[i];
                        const p1 = path.points[i+1];
                        
                        const minX = Math.min(p0.p.x, p1.p.x) - threshold;
                        const maxX = Math.max(p0.p.x, p1.p.x) + threshold;
                        const minY = Math.min(p0.p.y, p1.p.y) - threshold;
                        const maxY = Math.max(p0.p.y, p1.p.y) + threshold;
                        if (x < minX || x > maxX || y < minY || y > maxY) continue;

                        const { t, dist } = getTFromPoint(p0.p, p0.cOut, p1.cIn, p1.p, {x, y});
                        if (dist < minDist) {
                            minDist = dist;
                            const b = cubicBezier(p0.p, p0.cOut, p1.cIn, p1.p, t);
                            bestTarget = { 
                                type: 'segment', 
                                x: b.x, 
                                y: b.y, 
                                pathIdx: pIdx, 
                                segIdx: i, 
                                t: t 
                            };
                        }
                    }
                });
            }

            return bestTarget;
        }

        function processDrag(x, y) {
            if (AppState.isDraggingHandle) {
                const { index, subType, pathIndex } = AppState.activeHandleIndex;
                const pathData = AppState.paths[pathIndex];
                const pointData = pathData.points[index];
                
                let targetPoint = pointData.p;
                if (subType === 'cOut') targetPoint = pointData.cOut;
                if (subType === 'cIn') targetPoint = pointData.cIn;

                const dx = x - AppState.dragStartMouse.x;
                const dy = y - AppState.dragStartMouse.y;
                
                let nextX = targetPoint.x + dx;
                let nextY = targetPoint.y + dy;

                if (subType === '') {
                    const snap = findSnapTarget(nextX, nextY, pathIndex, index);
                    
                    if (snap) {
                        const mouseDistToTarget = Math.hypot(x - snap.x, y - snap.y);
                        
                        if (mouseDistToTarget <= AppState.styles.snapThreshold) {
                            nextX = snap.x;
                            nextY = snap.y;
                            AppState.isSnapping = true;
                            AppState.snapTarget = snap;
                            
                            UI.layerSnap.style.display = 'block';
                            UI.snapRing.setAttribute('cx', nextX);
                            UI.snapRing.setAttribute('cy', nextY);
                            UI.snapCenter.setAttribute('cx', nextX);
                            UI.snapCenter.setAttribute('cy', nextY);
                        } else {
                            AppState.isSnapping = false;
                            AppState.snapTarget = null;
                            UI.layerSnap.style.display = 'none';
                        }
                    } else {
                        AppState.isSnapping = false;
                        AppState.snapTarget = null;
                        UI.layerSnap.style.display = 'none';
                    }
                } else {
                    UI.layerSnap.style.display = 'none';
                }

                targetPoint.x = nextX;
                targetPoint.y = nextY;

                AppState.dragStartMouse = { x, y }; 
                updatePathD(pathIndex);
                renderSelectionHandles(); 
                
            } else if (AppState.isDraggingPath) {
                UI.layerSnap.style.display = 'none';
                const dx = x - AppState.dragStartMouse.x;
                const dy = y - AppState.dragStartMouse.y;
                
                AppState.selectedPathIndices.forEach(idx => {
                    const pathData = AppState.paths[idx];
                    pathData.points.forEach(pt => {
                        pt.p.x += dx; pt.p.y += dy;
                        pt.cIn.x += dx; pt.cIn.y += dy;
                        pt.cOut.x += dx; pt.cOut.y += dy;
                    });
                    updatePathD(idx);
                });

                AppState.dragStartMouse = { x, y }; 
                renderSelectionHandles();

            } else if (AppState.isDraggingSegment) {
                UI.layerSnap.style.display = 'none';
                const dx = x - AppState.dragStartMouse.x;
                const dy = y - AppState.dragStartMouse.y;
                const pathData = AppState.paths[AppState.activePathIndex];
                const segIndex = AppState.activeSegmentIndex;
                
                pathData.points[segIndex].cOut.x += dx;
                pathData.points[segIndex].cOut.y += dy;

                pathData.points[segIndex+1].cIn.x += dx;
                pathData.points[segIndex+1].cIn.y += dy;

                AppState.dragStartMouse = { x, y };
                updatePathD(AppState.activePathIndex);
                renderSelectionHandles();
            }
        }

        function stopDrag() {
            UI.layerSnap.style.display = 'none';
            
            if (AppState.isDraggingHandle || AppState.isDraggingPath || AppState.isDraggingSegment) {
                AppState.selectedPathIndices.forEach(idx => updatePathD(idx));

                if (AppState.isDraggingHandle && AppState.snapTarget) {
                    const { index, subType, pathIndex } = AppState.activeHandleIndex;
                    const snap = AppState.snapTarget;
                    const pathData = AppState.paths[pathIndex];
                    
                    if (subType === '') { 
                        saveState(); 

                        if (snap.type === 'anchor' && snap.pathIdx === pathIndex) {
                            const pts = pathData.points;
                            const isStart = index === 0;
                            const isEnd = index === pts.length - 1;
                            const targetIsStart = snap.ptIdx === 0;
                            const targetIsEnd = snap.ptIdx === pts.length - 1;

                            if (!pathData.closed && ((isStart && targetIsEnd) || (isEnd && targetIsStart))) {
                                pathData.closed = true;
                                setStatus("Shape closed by snapping! Fill remains transparent.");
                                updateCloseShapeUI();
                            }
                        }
                        
                        if (snap.type === 'segment') {
                            const targetPath = AppState.paths[snap.pathIdx];
                            const p0 = targetPath.points[snap.segIdx];
                            const p1 = targetPath.points[snap.segIdx+1];
                            
                            const { leftNode, splitNode, rightNode } = splitBezierCurve(
                                p0.p, p0.cOut, p1.cIn, p1.p, snap.t
                            );

                            if (snap.pathIdx === pathIndex) {
                                if (snap.segIdx < index) index++; 
                                targetPath.points[snap.segIdx].cOut = leftNode.cOut;
                                targetPath.points[snap.segIdx+1].cIn = rightNode.cIn;
                                targetPath.points.splice(snap.segIdx + 1, 0, splitNode);
                                
                                pathData.points[index].p.x = splitNode.p.x;
                                pathData.points[index].p.y = splitNode.p.y;
                                pathData.points[index].cIn.x = splitNode.cIn.x; 
                                pathData.points[index].cIn.y = splitNode.cIn.y;
                            } else {
                                targetPath.points[snap.segIdx].cOut = leftNode.cOut;
                                targetPath.points[snap.segIdx+1].cIn = rightNode.cIn;
                                targetPath.points.splice(snap.segIdx + 1, 0, splitNode);
                                
                                pathData.points[index].p.x = splitNode.p.x;
                                pathData.points[index].p.y = splitNode.p.y;
                                pathData.points[index].cIn.x = splitNode.cIn.x;
                                pathData.points[index].cIn.y = splitNode.cIn.y;
                            }
                        }
                    }
                }
                
                AppState.isDraggingHandle = false;
                AppState.isDraggingPath = false;
                AppState.isDraggingSegment = false;
                AppState.activeHandleIndex = null;
                AppState.activeSegmentIndex = null;
                AppState.activePathIndex = null;
                AppState.isSnapping = false;
                AppState.snapTarget = null;
                saveState();
            }
        }

        // --- EVENT LISTENERS ---

        UI.btnDraw.addEventListener('click', () => setMode('draw'));
        UI.btnSelect.addEventListener('click', () => setMode('select'));
        UI.btnCloseToolbar.addEventListener('click', toggleToolbar);
        UI.fab.addEventListener('click', toggleToolbar);

        UI.btnCloseShape.addEventListener('click', () => {
            saveState();

            // 1. Handle Merge of Two Paths
            if (AppState.selectedPathIndices.length === 2) {
                const idx1 = AppState.selectedPathIndices[0];
                const idx2 = AppState.selectedPathIndices[1];
                const path1 = AppState.paths[idx1];
                const path2 = AppState.paths[idx2];

                const p1Start = path1.points[0].p;
                const p1End = path1.points[path1.points.length - 1].p;
                const p2Start = path2.points[0].p;
                const p2End = path2.points[path2.points.length - 1].p;

                const distStartStart = Math.hypot(p1Start.x - p2Start.x, p1Start.y - p2Start.y);
                const distStartEnd = Math.hypot(p1Start.x - p2End.x, p1Start.y - p2End.y);
                const distEndStart = Math.hypot(p1End.x - p2Start.x, p1End.y - p2Start.y);
                const distEndEnd = Math.hypot(p1End.x - p2End.x, p1End.y - p2End.y);

                const minDist = Math.min(distStartStart, distStartEnd, distEndStart, distEndEnd);

                let p2Array = [...path2.points];
                let p2NeedsReverse = false;

                if (minDist === distEndStart) {
                } else if (minDist === distStartEnd) {
                    reversePathPoints(path1);
                    p2NeedsReverse = true;
                } else if (minDist === distEndEnd) {
                    p2NeedsReverse = true;
                } else if (minDist === distStartStart) {
                    reversePathPoints(path1);
                }

                if (p2NeedsReverse) {
                    p2Array.reverse();
                }

                path1.points = path1.points.concat(p2Array);
                path1.closed = false; 
                
                const pathEl2 = UI.layerPaths.querySelector(`path[data-index="${idx2}"]`);
                if(pathEl2) pathEl2.remove();
                AppState.paths.splice(idx2, 1);

                AppState.selectedPathIndices = [Math.min(idx1, idx2)];

                rebuildCanvas();
                setStatus("Two paths merged.");
                return;
            }

            // 2. Handle Single Path Close/Open
            if (AppState.selectedPathIndices.length === 1) {
                const idx = AppState.selectedPathIndices[0];
                const path = AppState.paths[idx];
                path.closed = !path.closed;
                
                // FIX: Removed the automatic opacity change. 
                // It now stays at 0 (or whatever the user set it to).
                if (path.closed) {
                    setStatus("Shape closed. Fill remains at " + (path.fillOpacity * 100) + "%.");
                } else {
                    setStatus("Shape opened.");
                }

                updatePathD(idx);
                renderSelectionHandles();
                updateCloseShapeUI();
                return;
            } 
            
            // 3. Default Toggle
            AppState.styles.autoClose = !AppState.styles.autoClose;
            setStatus(AppState.styles.autoClose ? "New shapes will auto-close." : "New shapes will stay open.");
            updateCloseShapeUI();
        });

        function reversePathPoints(pathData) {
            pathData.points.reverse();
            pathData.points.forEach(pt => {
                const temp = pt.cIn;
                pt.cIn = pt.cOut;
                pt.cOut = temp;
            });
        }

        function setMode(newMode) {
            AppState.mode = newMode;
            updateFabIcon();

            if (newMode === 'draw') {
                UI.body.className = 'mode-draw';
                UI.btnDraw.classList.add('active');
                UI.btnSelect.classList.remove('active');
                AppState.selectedPathIndices = []; 
                updateSelectionVisuals();
                setStatus("<b>Draw Mode:</b> Sketch freely.<br>Toolbar moves away if you get close.");
            } else {
                stopDrawing(); 
                UI.body.className = 'mode-select';
                UI.btnSelect.classList.add('active');
                UI.btnDraw.classList.remove('active');
                setStatus("<b>Select Mode:</b> Double-click Anchor (Square) to delete. Double-click line to add.");
            }
        }

        window.addEventListener('mousemove', (e) => {
            const pt = getSVGPoint(e.clientX, e.clientY);
            checkToolbarProximity(e.clientX); 

            if (AppState.mode === 'draw') {
                if (!AppState.isDrawing) {
                    startDrawing(pt.x, pt.y);
                } else {
                    drawMove(pt.x, pt.y);
                }
            } else {
                if (AppState.isDraggingHandle || AppState.isDraggingPath || AppState.isDraggingSegment) {
                    processDrag(pt.x, pt.y);
                }
            }
        });

        UI.canvas.addEventListener('mousedown', (e) => {
            if (AppState.mode === 'select') {
                if (e.target.classList.contains('path-element')) {
                    const clickedIndex = parseInt(e.target.dataset.index);
                    startDraggingSegment(e, clickedIndex);
                } else if (e.target.tagName !== 'rect' && e.target.tagName !== 'circle' && !e.target.closest('.path-mover-group') && !e.target.closest('.handle-group')) {
                    toggleSelection(-1, false);
                }
            }
        });

        window.addEventListener('mouseup', () => {
            if (AppState.mode === 'draw') {
                stopDrawing();
            } else {
                stopDrag();
            }
        });

        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (e.code === 'Space') {
                e.preventDefault();
                setMode(AppState.mode === 'draw' ? 'select' : 'draw');
                return;
            }
            if (key === 'x') { toggleToolbar(); return; }
            if ((e.ctrlKey || e.metaKey) && key === 'z') undo();
            else if ((e.ctrlKey || e.metaKey) && key === 'y') redo();
            else if (key === 'z') undo();
            else if (key === 'y') redo();
            else if (key === 'delete' || key === 'backspace') {
                if (AppState.selectedPathIndices.length > 0) {
                    deleteSelectedPaths();
                } else {
                    // New Feature: Clear Background
                    clearBackground();
                }
            }
        });

        function clearBackground() {
            UI.bgLayer.style.backgroundImage = 'none';
            setStatus("Background cleared.");
        }

        function updateStyleProperty(key, value, isFloat = false) {
            AppState.styles[key] = isFloat ? parseFloat(value) : value;
            
            if (AppState.selectedPathIndices.length > 0) {
                AppState.selectedPathIndices.forEach(idx => {
                    const pathData = AppState.paths[idx];
                    pathData[key] = AppState.styles[key];
                    const pathEl = UI.layerPaths.querySelector(`path[data-index="${idx}"]`);
                    if (pathEl) {
                        if(key === 'strokeColor') pathEl.setAttribute("stroke", value);
                        if(key === 'fillColor') pathEl.setAttribute("fill", value);
                        if(key === 'width') pathEl.setAttribute("stroke-width", value);
                        if(key === 'strokeOpacity') pathEl.setAttribute("stroke-opacity", value);
                        if(key === 'fillOpacity') pathEl.setAttribute("fill-opacity", value);
                    }
                });
            }
        }

        UI.widthSlider.addEventListener('input', (e) => {
            const val = e.target.value;
            updateStyleProperty('width', val);
            UI.widthVal.textContent = val + "px";
        });
        UI.widthSlider.addEventListener('change', () => { if(AppState.selectedPathIndices.length > 0) saveState(); });
        UI.strokeColor.addEventListener('input', (e) => updateStyleProperty('strokeColor', e.target.value));
        UI.strokeColor.addEventListener('change', () => { if(AppState.selectedPathIndices.length > 0) saveState(); });
        UI.fillColor.addEventListener('input', (e) => updateStyleProperty('fillColor', e.target.value));
        UI.fillColor.addEventListener('change', () => { if(AppState.selectedPathIndices.length > 0) saveState(); });
        UI.strokeOpacity.addEventListener('input', (e) => updateStyleProperty('strokeOpacity', e.target.value, true));
        UI.strokeOpacity.addEventListener('change', () => { if(AppState.selectedPathIndices.length > 0) saveState(); });
        UI.fillOpacity.addEventListener('input', (e) => updateStyleProperty('fillOpacity', e.target.value, true));
        UI.fillOpacity.addEventListener('change', () => { if(AppState.selectedPathIndices.length > 0) saveState(); });

        function deleteSelectedPaths() {
            if (AppState.selectedPathIndices.length === 0) return;
            
            const indicesToDelete = [...AppState.selectedPathIndices].sort((a, b) => b - a);
            
            saveState();
            
            indicesToDelete.forEach(idx => {
                const pathEl = UI.layerPaths.querySelector(`path[data-index="${idx}"]`);
                if (pathEl) pathEl.remove();
                AppState.paths.splice(idx, 1);
            });

            AppState.selectedPathIndices = [];
            clearHandles();
            Array.from(UI.layerPaths.children).forEach((el, idx) => el.dataset.index = idx);
            
            updateSelectionVisuals();
        }
        UI.btnDelete.addEventListener('click', deleteSelectedPaths);

        UI.btnClear.addEventListener('click', () => {
            if(confirm("Clear entire canvas?")) {
                saveState();
                AppState.paths = [];
                AppState.selectedPathIndices = [];
                UI.layerPaths.innerHTML = '';
                UI.layerHandles.innerHTML = '';
                updateSelectionVisuals();
            }
        });

        // --- Export ---
        UI.btnExport.addEventListener('click', () => {
            if (AppState.paths.length === 0) return;
            const svgContent = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svgContent.setAttribute("xmlns", "http://www.w3.org/2000/svg");
            svgContent.setAttribute("viewBox", `0 0 ${window.innerWidth} ${window.innerHeight}`);
            
            AppState.paths.forEach(pathData => {
                const pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");
                pathEl.setAttribute("stroke", pathData.strokeColor);
                pathEl.setAttribute("stroke-width", pathData.width);
                pathEl.setAttribute("stroke-opacity", pathData.strokeOpacity !== undefined ? pathData.strokeOpacity : 1);
                pathEl.setAttribute("fill", pathData.fillColor);
                pathEl.setAttribute("fill-opacity", pathData.fillOpacity !== undefined ? pathData.fillOpacity : 0);
                pathEl.setAttribute("stroke-linecap", "round");
                pathEl.setAttribute("stroke-linejoin", "round");
                
                const pts = pathData.points;
                let d = `M ${pts[0].p.x.toFixed(1)} ${pts[0].p.y.toFixed(1)}`;
                for (let i = 0; i < pts.length - 1; i++) {
                    const p1 = pts[i];
                    const p2 = pts[i+1];
                    d += ` C ${p1.cOut.x.toFixed(1)} ${p1.cOut.y.toFixed(1)}, ${p2.cIn.x.toFixed(1)} ${p2.cIn.y.toFixed(1)}, ${p2.p.x.toFixed(1)} ${p2.p.y.toFixed(1)}`;
                }
                if (pathData.closed) {
                    d += " Z";
                }
                pathEl.setAttribute("d", d);
                svgContent.appendChild(pathEl);
            });

            const serializer = new XMLSerializer();
            let source = serializer.serializeToString(svgContent);
            if(!source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)){
                source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
            }
            if(!source.match(/^<svg[^>]+xmlns:xlink/)){
                source = source.replace(/^<svg/, '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
            }

            const blob = new Blob([source], {type: "image/svg+xml;charset=utf-8"});
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = `slidus_sketch_${Date.now()}.svg`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        // --- Drag & Drop Background ---
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            UI.app.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });
        
        setMode('select');

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        UI.app.addEventListener('dragenter', () => document.body.classList.add('drag-over'));
        UI.app.addEventListener('dragleave', (e) => {
            if (e.relatedTarget && !UI.app.contains(e.relatedTarget)) {
                document.body.classList.remove('drag-over');
            }
        });
        UI.app.addEventListener('drop', (e) => {
            document.body.classList.remove('drag-over');
            const dt = e.dataTransfer;
            const files = dt.files;
            if (files.length > 0) handleFiles(files);
        });

        function handleFiles(files) {
            const file = files[0];
            if (!file.type.startsWith('image/')) return;
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onloadend = function() {
                UI.bgLayer.style.backgroundImage = `url('${reader.result}')`;
            }
        }
    </script>
</body>
</html>
